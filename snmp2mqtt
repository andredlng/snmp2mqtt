#!/usr/bin/env python

import argparse
import asyncio
import json
import logging
import signal
import sys
import time
from typing import Any, Dict, List, Optional, Tuple

import paho.mqtt.client as mqtt
from pysnmp.hlapi.v3arch.asyncio import *


mqtt_client: Optional[mqtt.Client] = None
daemon_args = None
snmp_engine = None
poll_tasks: List[asyncio.Task] = []


def parse_args():
    parser = argparse.ArgumentParser(
        prog='snmp2mqtt',
        description='An SNMP to MQTT bridge',
        epilog='Have a lot of fun!'
    )
    # MQTT options
    parser.add_argument('-m', '--mqtt_host', type=str, default='localhost', help='MQTT server hostname.')
    parser.add_argument('--mqtt_port', type=int, default=1883, help='MQTT server port.')
    parser.add_argument('--mqtt_keepalive', type=int, default=30, help='MQTT keep alive (seconds).')
    parser.add_argument('--mqtt_clientid', type=str, default='snmp2mqtt', help='MQTT client id.')
    parser.add_argument('-u', '--mqtt_user', type=str, help='MQTT username.')
    parser.add_argument('-p', '--mqtt_password', type=str, help='MQTT password.')
    parser.add_argument('-t', '--mqtt_topic', type=str, default='bus/snmp', help='Base topic to publish messages.')
    parser.add_argument('--mqtt_tls', default=False, action='store_true', help='Enable MQTT TLS.')
    parser.add_argument('--mqtt_tls_version', type=str, default='TLSv1.2', help='TLS version (TLSv1, TLSv1.1, TLSv1.2).')
    parser.add_argument('--mqtt_verify_mode', type=str, default='CERT_REQUIRED', help='TLS verify mode (CERT_NONE, CERT_OPTIONAL, CERT_REQUIRED).')
    parser.add_argument('--mqtt_ssl_ca_path', type=str, help='CA file path for MQTT TLS.')
    parser.add_argument('--mqtt_tls_no_verify', default=False, action='store_true', help='Disable TLS hostname verification.')

    # General
    parser.add_argument('-c', '--config', type=str, default='/etc/snmp2mqtt.conf', help='Path to config file.')
    parser.add_argument('-z', '--timestamp', default=False, action='store_true', help='Publish timestamps for all topics.')
    parser.add_argument('-v', '--verbose', default=False, action='store_true', help='Verbose logging.')
    return parser.parse_args()


def parse_config():
    global daemon_args
    daemon_args.targets = []
    if daemon_args.config and not os_path_isfile(daemon_args.config):
        return
    if not daemon_args.config:
        return
    with open(daemon_args.config, 'r') as f:
        data = json.load(f)
        for k in (
            'mqtt_host', 'mqtt_port', 'mqtt_keepalive', 'mqtt_clientid', 'mqtt_user', 'mqtt_password',
            'mqtt_topic', 'mqtt_tls', 'mqtt_tls_version', 'mqtt_verify_mode', 'mqtt_ssl_ca_path', 'mqtt_tls_no_verify',
            'timestamp', 'verbose'
        ):
            if k in data:
                v = data[k]
                if isinstance(getattr(daemon_args, k, None), bool) and isinstance(v, str):
                    v = v.lower() == 'true'
                setattr(daemon_args, k, v)
        if 'targets' in data:
            daemon_args.targets = data['targets']


def os_path_isfile(path: str) -> bool:
    try:
        import os
        return os.path.isfile(path)
    except Exception:
        return False


verify_mode = {
    'CERT_NONE': __import__('ssl').CERT_NONE,
    'CERT_OPTIONAL': __import__('ssl').CERT_OPTIONAL,
    'CERT_REQUIRED': __import__('ssl').CERT_REQUIRED,
}

tls_versions = {
    'TLSv1': __import__('ssl').PROTOCOL_TLSv1,
    'TLSv1.1': __import__('ssl').PROTOCOL_TLSv1_1,
    'TLSv1.2': __import__('ssl').PROTOCOL_TLSv1_2,
}


def init_mqtt():
    logging.debug('Starting MQTT')
    global daemon_args
    client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, daemon_args.mqtt_clientid)
    if daemon_args.mqtt_tls:
        cert_reqs = verify_mode.get(daemon_args.mqtt_verify_mode)
        tls_version = tls_versions.get(daemon_args.mqtt_tls_version)
        ca_certs = daemon_args.mqtt_ssl_ca_path if daemon_args.mqtt_ssl_ca_path else None
        client.tls_set(ca_certs=ca_certs, cert_reqs=cert_reqs, tls_version=tls_version)
        client.tls_insecure_set(daemon_args.mqtt_tls_no_verify)
    if daemon_args.verbose:
        client.enable_logger()
    if daemon_args.mqtt_user and daemon_args.mqtt_password:
        client.username_pw_set(daemon_args.mqtt_user, daemon_args.mqtt_password)
    client.connect(daemon_args.mqtt_host, daemon_args.mqtt_port, daemon_args.mqtt_keepalive)
    return client


def _auth_protocol(name: Optional[str]):
    if not name:
        return usmNoAuthProtocol
    m = {
        'MD5': 'usmHMACMD5AuthProtocol',
        'SHA': 'usmHMACSHAAuthProtocol',
        'SHA224': 'usmHMAC128SHA224AuthProtocol',
        'SHA256': 'usmHMAC192SHA256AuthProtocol',
        'SHA384': 'usmHMAC256SHA384AuthProtocol',
        'SHA512': 'usmHMAC384SHA512AuthProtocol',
    }
    attr = m.get(name.upper(), 'usmHMACSHAAuthProtocol')
    return getattr(globals(), attr, usmHMACSHAAuthProtocol)


def _priv_protocol(name: Optional[str]):
    if not name:
        return usmNoPrivProtocol
    m = {
        'DES': 'usmDESPrivProtocol',
        '3DES': 'usm3DESEDEPrivProtocol',
        'AES': 'usmAesCfb128Protocol',
        'AES128': 'usmAesCfb128Protocol',
        'AES192': 'usmAesCfb192Protocol',
        'AES256': 'usmAesCfb256Protocol',
    }
    attr = m.get(name.upper(), 'usmAesCfb128Protocol')
    return getattr(globals(), attr, usmAesCfb128Protocol)


def build_auth(target: Dict[str, Any]):
    version = (target.get('version') or 'v2c').lower()
    if version in ('v1', 'v2c'):
        mp_model = 0 if version == 'v1' else 1
        return CommunityData(target.get('community', 'public'), mpModel=mp_model)
    # v3
    level = (target.get('level') or 'noAuthNoPriv')
    user = target.get('user')
    auth_key = target.get('auth_key')
    priv_key = target.get('priv_key')
    if level == 'noAuthNoPriv':
        return UsmUserData(user)
    elif level == 'authNoPriv':
        return UsmUserData(user, authKey=auth_key, authProtocol=_auth_protocol(target.get('auth_protocol')))
    elif level == 'authPriv':
        return UsmUserData(
            user,
            authKey=auth_key,
            authProtocol=_auth_protocol(target.get('auth_protocol')),
            privKey=priv_key,
            privProtocol=_priv_protocol(target.get('priv_protocol')),
        )
    else:
        return UsmUserData(user)


def _transform(value_str: str, transform: Optional[str]) -> str:
    if not transform:
        return value_str
    try:
        if transform == 'int':
            return str(int(float(value_str)))
        if transform == 'float':
            return str(float(value_str))
        if transform == 'str':
            return str(value_str)
    except Exception:
        pass
    return value_str


async def poll_scalar_once(auth, transport, oid: str) -> List[Tuple[str, str]]:
    errorIndication, errorStatus, errorIndex, varBinds = await get_cmd(
        snmp_engine,
        auth,
        transport,
        ContextData(),
        ObjectType(ObjectIdentity(oid)),
    )
    results: List[Tuple[str, str]] = []
    if errorIndication:
        raise RuntimeError(str(errorIndication))
    if errorStatus:
        raise RuntimeError(f"{errorStatus.prettyPrint()} at {errorIndex}")
    for name, val in varBinds:
        results.append((name.prettyPrint(), val.prettyPrint()))
    return results


async def poll_scalar(target_name: str, auth, transport, oid_cfg: Dict[str, Any]):
    base_topic = f"{daemon_args.mqtt_topic}/{target_name}"
    oid = oid_cfg['oid']
    name = oid_cfg.get('name') or oid
    while True:
        try:
            varBinds = await poll_scalar_once(auth, transport, oid)
            for _name, val in varBinds:
                payload = _transform(val, oid_cfg.get('transform'))
                publish_mqtt(f"{base_topic}/{name}", payload)
        except Exception as e:
            logging.warning(f"SNMP GET error for {target_name} {oid}: {e}")
        await asyncio.sleep(int(target_interval(transport)))


def target_interval(transport) -> int:
    # transport is UdpTransportTarget((host, port), timeout=..., retries=...)
    # store desired interval on transport via attribute
    return getattr(transport, '_interval', 30)


def set_target_interval(transport, interval: int):
    setattr(transport, '_interval', max(1, int(interval)))


def compute_index_suffix(root_oid: str, full_oid: str) -> str:
    if full_oid.startswith(root_oid + '.'):
        return full_oid[len(root_oid) + 1:]
    return ''


async def walk_once(auth, transport, root_oid: str) -> List[Tuple[str, str]]:
    results: List[Tuple[str, str]] = []
    async for (errorIndication, errorStatus, errorIndex, varBinds) in next_cmd(
        snmp_engine,
        auth,
        transport,
        ContextData(),
        ObjectType(ObjectIdentity(root_oid)),
        lexicographicMode=False,
    ):
        if errorIndication:
            raise RuntimeError(str(errorIndication))
        if errorStatus:
            raise RuntimeError(f"{errorStatus.prettyPrint()} at {errorIndex}")
        for name, val in varBinds:
            results.append((name.prettyPrint(), val.prettyPrint()))
    return results


async def poll_walk(target_name: str, auth, transport, oid_cfg: Dict[str, Any]):
    base_topic = f"{daemon_args.mqtt_topic}/{target_name}"
    root_oid = oid_cfg['oid']
    while True:
        try:
            varBinds = await walk_once(auth, transport, root_oid)
            for name_str, val_str in varBinds:
                index = compute_index_suffix(root_oid, name_str)
                topic = f"{base_topic}/{oid_cfg.get('name') or root_oid}"
                if index:
                    topic = f"{topic}/{index}"
                payload = _transform(val_str, oid_cfg.get('transform'))
                publish_mqtt(topic, payload)
        except Exception as e:
            logging.warning(f"SNMP WALK loop error for {target_name} {root_oid}: {e}")
        await asyncio.sleep(int(target_interval(transport)))


def publish_mqtt(topic: str, value: Any):
    global mqtt_client, daemon_args
    logging.info(f"Topic: {topic}, Payload: {value}")
    mqtt_client.publish(topic, str(value))
    if daemon_args.timestamp:
        mqtt_client.publish(f"{topic}/timestamp", time.time(), retain=True)


async def run_target(target: Dict[str, Any]):
    global snmp_engine
    name = target.get('name') or f"{target.get('host')}_{target.get('port',161)}"
    auth = build_auth(target)
    host = target.get('host', 'localhost')
    port = int(target.get('port', 161))
    timeout = int(target.get('timeout', 1))
    retries = int(target.get('retries', 3))
    interval = int(target.get('interval', 30))
    transport = await UdpTransportTarget.create((host, port), timeout=timeout, retries=retries)
    set_target_interval(transport, interval)

    tasks = []
    for oid_cfg in (target.get('oids') or []):
        if oid_cfg.get('walk'):
            tasks.append(asyncio.create_task(poll_walk(name, auth, transport, oid_cfg)))
        else:
            tasks.append(asyncio.create_task(poll_scalar(name, auth, transport, oid_cfg)))
    try:
        await asyncio.gather(*tasks)
    except asyncio.CancelledError:
        for t in tasks:
            t.cancel()
        raise


def shutdown(signum, frame):
    logging.info('Shutdown...')
    if mqtt_client is not None:
        logging.info('Stopping MQTT')
        mqtt_client.loop_stop()
        mqtt_client.disconnect()
    try:
        loop = asyncio.get_event_loop()
        for task in poll_tasks:
            task.cancel()
    except Exception:
        pass
    logging.info('Bye!')
    sys.exit(0)


async def main_async():
    global daemon_args, mqtt_client, snmp_engine, poll_tasks
    snmp_engine = SnmpEngine()

    # MQTT connection
    mqtt_client = init_mqtt()
    mqtt_client.loop_start()

    # Start targets
    for target in daemon_args.targets:
        poll_tasks.append(asyncio.create_task(run_target(target)))

    await asyncio.gather(*poll_tasks)


def main():
    global daemon_args
    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)

    daemon_args = parse_args()
    parse_config()

    if daemon_args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    asyncio.run(main_async())


if __name__ == '__main__':
    main()
